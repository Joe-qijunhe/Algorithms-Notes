[toc]

# 排序

## 数组的相对位置

>   给你两个数组，arr1 和 arr2，
>
>   arr2 中的元素各不相同
>
>   arr2 中的每个元素都出现在 arr1 中
>
>   对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。
>
>   示例：
>
>   输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
>   输出：[2,2,2,1,4,3,3,9,6,7,19]

法一：自定义排序

由于数组 arr2 规定了比较顺序，因此我们可以使用哈希表对该顺序进行映射：即对于数组arr 2中的第 i 个元素，我们将(arr2[i],i) 这一键值对放入哈希表rank 中，就可以很方便地对数组arr1中的元素进行比较。

```java
public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Map<Integer, Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList<>();
        for(int num : arr1) list.add(num);
        for(int i = 0; i < arr2.length; i++) map.put(arr2[i], i);
        Collections.sort(list, (x, y) -> {
            if(map.containsKey(x) || map.containsKey(y)) return map.getOrDefault(x, 1001) - map.getOrDefault(y, 1001);
            return x - y;
        });
        for(int i = 0; i < arr1.length; i++) arr1[i] = list.get(i);
        return arr1;
    }
```

注：最大的值是1000，这里设置为1001的目的是确保不在arr2中的数一定排在arr2后面

法二：计算排序

把arr1中元素以及出现的次数放到map当中，遍历arr2，将出现次数个arr2中的元素加入答案中。最后再遍历map，答案加入arr1独有的元素。

```java
public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Map<Integer, Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList<>();
        for(int num : arr1){
            if (map.containsKey(num)){
                map.put(num, map.get(num)+1);
            }else{
                map.put(num,1);
            }
        }
        for(int i = 0; i < arr2.length; i++){
            int times = map.get(arr2[i]);
            map.remove(arr2[i]);
            for (int j  = 0 ; j < times; j++) list.add(arr2[i]);
        }
        List<Integer> tmp = new  ArrayList<>();
        for (Map.Entry<Integer, Integer> s : map.entrySet()){
            for (int k = 0; k < s.getValue(); k++) tmp.add(s.getKey());
        }
        tmp.sort(Integer::compareTo);
        list.addAll(tmp);
        for(int i = 0; i < arr1.length; i++) arr1[i] = list.get(i);
        return arr1;
    }

```

