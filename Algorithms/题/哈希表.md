[toc]

# 哈希表

## 两数之和

>   给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值的那 两个整数，并返回它们的数组下标。
>
>   你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
>   你可以按任意顺序返回答案。
>
>   示例一：
>
>   输入：nums = [2,7,11,15], target = 9
>   输出：[0,1]
>   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
>
>   示例二：
>
>   输入：nums = [3,3], target = 6
>
>   输出：[0,1]

注：不能把nums全都加入到hashmap中，因为可能会有重复的（示例二），想get(target - nums[i])时可能返回错误的索引

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```

## 只出现一次的数字

>   给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
>   示例一：
>
>   输入: [2,2,1]
>   输出: 1
>
>   示例二：
>
>   输入: [4,1,2,1,2]
>   输出: 4

法一：排序遍历

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 1; i += 2){
            if(nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }   
        return nums[nums.length - 1];
    }
}
```

法二：哈希表

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count == 1) {
                return i;
            }
        }
        return -1; // can't find it.
    }
}
```

法三：异或 (线性时间复杂度和常数空间复杂度)

异或运算有以下三个性质。

-   任何数和 0 做异或运算，结果仍然是原来的数
-   任何数和其自身做异或运算，结果是 0
-   异或运算满足交换律和结合律

由于题目说只有一个num是只出现一次，其他均出现两次。遍历数组，出现两次的异或会变成0，0异或其他数还是等于自身。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}
```

## 快乐数

>   编写一个算法来判断一个数 n 是不是快乐数。
>
>   快乐数定义为：
>
>   对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
>   然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
>   如果 可以变为  1，那么这个数就是快乐数。
>   如果 n 是快乐数就返回 true ；不是，则返回 false 。
>
>   示例 1：
>
>   输入：19
>   输出：true
>   解释：
>   1^2 + 9^2 = 82
>   8^2 + 2^2 = 68
>   6^2 + 8^2 = 100
>   1^2 + 0^2 + 0^2 = 1
>
>   **示例 2：**
>
>   输入：n = 2
>   输出：false

法一：哈希集合检测循环

快乐数有以下三种可能。

1.  最终会得到 1。
2.  最终会进入循环。
3.  值会越来越大，最后接近无穷大。（不可能）

第 1 部分我们按照题目的要求做数位分离，求平方和。

第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。如果它不在哈希集合中，我们应该添加它。如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。

```java
class Solution {
    private int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getNext(n);
        }
        return n == 1;
    }
}
```

法二：快慢指针

通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。

```java
class Solution {

     public int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        int slowRunner = n;
        int fastRunner = getNext(n);
        while (fastRunner != 1 && slowRunner != fastRunner) {
            slowRunner = getNext(slowRunner);
            fastRunner = getNext(getNext(fastRunner));
        }
        return fastRunner == 1;
    }
}
```

## 单词规律

>   给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。
>
>   这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。
>
>   示例1:
>
>   输入: pattern = "abba", str = "dog cat cat dog"
>   输出: true
>
>   示例 2:
>
>   输入:pattern = "abba", str = "dog cat cat fish"
>   输出: false
>
>   示例 3:
>
>   输入: pattern = "abba", str = "dog dog dog dog"
>   输出: false

任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应（如示例3，a对应着dog，b对应着dog，这就不行）。在集合论中，这种关系被称为双射。

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] strs = s.split(" ");
        if (pattern.length() != strs.length) return false;
        HashMap<Character, String> mapcs = new HashMap<>();
        HashMap<String, Character> mapsc = new HashMap<>();
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            String tmps = strs[i];
            if (mapcs.containsKey(ch) && !mapcs.get(ch).equals(tmps)) {
                return false;
            } 
            if (mapsc.containsKey(tmps)  && mapsc.get(tmps) != ch) {
                return false;
            }
            mapcs.put(ch, tmps);
            mapsc.put(tmps, ch);
        }
        return true;
    }
}
```

用containsValue()判断的话，时间复杂度会是O(n^2)