[toc]

# 链表

## 链表中的倒数第k个结点

>   输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
>
>    
>
>   示例：
>
>   给定一个链表: 1->2->3->4->5, 和 k = 2.
>
>   返回链表 4->5.

双指针：first指针在second指针前k个位置，当first为null时，返回second指针

```java
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode first = head;
        ListNode second = head;
        while(k-- > 0){
            first = first.next;
        }
        while(first != null){
            first = first.next;
            second = second.next;
        }
        return second;
    }
```

## 环形链表

>   给定一个链表，判断链表中是否有环。
>
>   如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。
>
>   如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。

假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。

我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

## 反转链表

>   输入: 1->2->3->4->5->NULL
>   输出: 5->4->3->2->1->NULL

### 链表栈法

x按顺序遍历原链表，把元素用头插入的方式插入reverseHead

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
    public ListNode reverseList(ListNode head) {
        ListNode reverseHead = null;
        for (ListNode x = head; x != null; x = x.next){
            reverseHead = new ListNode(x.val, reverseHead);
        }
        return reverseHead;
    }
```

### 迭代

三个指针prev，curr，next

```java
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
```

### 递归

递归到尾结点，他是新头结点，每次都return他并且修改指针（希望$x_{k+1}$指向$x_k$：$x_k.next.next = x_k$）

正序倒二.next.next = 倒二

正序倒二.next = null;

...

```java
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
```

## 合并链表

>   输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
>
>   示例1：
>
>   输入：1->2->4, 1->3->4
>   输出：1->1->2->3->4->4

这种做法会修改原先的链表l1，l2

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dum = new ListNode(0), cur = dum;
    while(l1 != null && l2 != null) {
        if(l1.val < l2.val) {
            cur.next = l1;
            l1 = l1.next;
        }
        else {
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    cur.next = l1 != null ? l1 : l2;	//单边补全
    return dum.next;
}
```

递归写法：

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    } else if (l2 == null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }

}
```

这种不会修改

```java
 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p = new ListNode(0);
        ListNode head = p;
        while (l1 != null || l2 != null) {
            if (l1 == null) {
                p.next = new ListNode(l2.val);
                p = p.next;
                l2 = l2.next;
            } else if (l2 == null) {
                p.next = new ListNode(l1.val);
                p = p.next;
                l1 = l1.next;
            } else if (l1.val < l2.val) {
                p.next = new ListNode(l1.val);
                p = p.next;
                l1 = l1.next;
            } else {
                p.next = new ListNode(l2.val);
                p = p.next;
                l2 = l2.next;
            }
        }
        return head.next;
    }
```

## 回文链表

>   请判断一个链表是否为回文链表。
>
>   示例 1:
>
>   输入: 1->2
>   输出: false
>
>   示例 2:
>
>   输入: 1->2->2->1
>   输出: true

法一：

反转链表，一个一个遍历比值

```java
public boolean isPalindrome(ListNode head) {
    ListNode reverseHead = null;
    for (ListNode x = head; x != null; x = x.next){
        reverseHead = new ListNode(x.val, reverseHead);
    }
    for (ListNode x = head; x != null; x = x.next, reverseHead = reverseHead.next){
        if (x.val != reverseHead.val){
            return false;
        }
    }
    return true;
}
```

法二：

currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val != frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。

```java
    private ListNode frontPointer;

    private boolean recursivelyCheck(ListNode currentNode) {
        if (currentNode != null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val != frontPointer.val) {
                return false;
            }
            frontPointer = frontPointer.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recursivelyCheck(head);
    }

```

法三：

整个流程可以分为以下五个步骤：

1.  找到前半部分链表的尾节点。
2.  反转后半部分链表。
3.  判断是否回文。
4.  恢复链表。
5.  返回结果。

可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。

若链表有奇数个节点：1-2-3-2-1 slow会在3停下

若链表有偶数个节点：1-2-4-4-2-1 slow会在4停下

```java
public boolean isPalindrome(ListNode head) {
        if (head == null) {
            return true;
        }

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode firstHalfEnd = endOfFirstHalf(head);
        ListNode secondHalfStart = reverseList(firstHalfEnd.next);

        // 判断是否回文
        ListNode p1 = head;
        ListNode p2 = secondHalfStart;
        boolean result = true;
        while (result && p2 != null) {
            if (p1.val != p2.val) {
                result = false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }        

        // 还原链表并返回结果
        firstHalfEnd.next = reverseList(secondHalfStart);
        return result;
    }

    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    private ListNode endOfFirstHalf(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

```
# 栈

## 前缀，中缀，后缀表达式

前缀（波兰表达式），后缀（逆波兰表达式）

前缀表达式从右到左扫描表达式，遇到数字，将数字压入堆栈，遇到运算符，弹出栈顶的两个数，运算并将结果压入栈（-和/的位置与后缀不同 上面减下面）

中缀表达式的求值一般转化成后缀表达式

后缀表达式从左到右扫描表达式，（下面-上面）

# 数组

## 交集

>   给定两个数组，编写一个函数来计算它们的交集。
>
>   输入：nums1 = [1,2,2,1], nums2 = [2,2] 
>
>   输出：[2,2]
>
>   输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 
>
>   输出：[4,9]

 方法一 Hash表

```java
    public int[] intersect(int[] nums1, int[] nums2) {
        int[] small = nums1.length < nums2.length ? nums1 : nums2;
        int[] bigger = nums1.length >= nums2.length ? nums1 : nums2;
        int[] re = new int[small.length];
        int i = 0;
        HashMap<Integer, Integer> map = new HashMap<>(small.length);
        for (int w : small) {
            if (map.containsKey(w)) {
                map.put(w, map.get(w) + 1);
            } else {
                map.put(w, 1);
            }
        }
        for (int a : bigger) {
            if (map.containsKey(a) && map.get(a) > 0) {
                map.put(a, map.get(a) - 1);
                re[i++] = a;
            }
        }
        return Arrays.copyOfRange(re, 0 , i);
    }
```

方法二

如果两个数组是有序的，则可以便捷地计算两个数组的交集。

首先对两个数组进行排序，然后使用两个指针遍历两个数组。

初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。

```java
public int[] intersect(int[] nums1, int[] nums2) {
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int length1 = nums1.length, length2 = nums2.length;
    int[] intersection = new int[Math.min(length1, length2)];
    int index1 = 0, index2 = 0, index = 0;
    while (index1 < length1 && index2 < length2) {
        if (nums1[index1] < nums2[index2]) {
            index1++;
        } else if (nums1[index1] > nums2[index2]) {
            index2++;
        } else {
            intersection[index] = nums1[index1];
            index1++;
            index2++;
            index++;
        }
    }
    return Arrays.copyOfRange(intersection, 0, index);
}
```

## 并集

```java
    public int[] union(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int index1 = 0, index2 = 0, index = 0;
        int[] re = new int[nums1.length + nums2.length];
        while (index1 < nums1.length && index2 < nums2.length) {
            if (nums1[index1] < nums2[index2]) {
                re[index++] = nums1[index1++];
            } else if (nums1[index1] > nums2[index2]) {
                re[index++] = nums2[index2++];
            } else {
                re[index] = nums1[index1];
                index1++;
                index2++;
                index++;
            }
        }
        while (index1 < nums1.length) {
            re[index++] = nums1[index1++];
        }
        while (index2 < nums2.length) {
            re[index++] = nums2[index2++];
        }
        return Arrays.copyOfRange(re, 0, index);
    }
```

