[toc]

# 链表

## 链表中的倒数第k个结点

>   输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
>
>    
>
>   示例：
>
>   给定一个链表: 1->2->3->4->5, 和 k = 2.
>
>   返回链表 4->5.

双指针：first指针在second指针前k个位置，当first为null时，返回second指针

```java
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode first = head;
        ListNode second = head;
        while(k-- > 0){
            first = first.next;
        }
        while(first != null){
            first = first.next;
            second = second.next;
        }
        return second;
    }
```

## 环形链表

>   给定一个链表，判断链表中是否有环。
>
>   如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。
>
>   如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。

假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。

我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

## 反转链表

>   输入: 1->2->3->4->5->NULL
>   输出: 5->4->3->2->1->NULL

### 链表栈法

x按顺序遍历原链表，把元素用头插入的方式插入reverseHead

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
    public ListNode reverseList(ListNode head) {
        ListNode reverseHead = null;
        for (ListNode x = head; x != null; x = x.next){
            reverseHead = new ListNode(x.val, reverseHead);
        }
        return reverseHead;
    }
```

### 迭代

三个指针prev，curr，next

```java
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
```

### 递归

希望$x_{k+1}$指向$x_k$：$x_{k+1}.next.next = x_k$

递归到尾结点，他是新头结点，每次都return他并且修改指针

```java
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
```

# 栈

## 前缀，中缀，后缀表达式

前缀（波兰表达式），后缀（逆波兰表达式）

前缀表达式从右到左扫描表达式，遇到数字，将数字压入堆栈，遇到运算符，弹出栈顶的两个数，运算并将结果压入栈（-和/的位置与后缀不同 上面减下面）

中缀表达式的求值一般转化成后缀表达式

后缀表达式从左到右扫描表达式，（下面-上面）

