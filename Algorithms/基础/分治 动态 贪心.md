[toc]

# 分治算法

把一个复杂的问题分为两个或者更多的相同或相似的子问题，再把子问题分成更小的子问题。直到最后子问题可以简单地直接求解，原问题地解由子问题地解合并。三步骤：

1.  分解：将原问题分为若干个规模较小，相互独立，与原问题形式相同的子问题
2.  解决：若子问题规模较小而容易被解决则直接解，否者递归地解各个子问题
3.  合并：将各个子问题的解合并为原问题地解

## 汉诺塔

如果有一个盘，A->C, 如果有大等2个盘，总是可以看做是两个盘，上面的盘和最下边的盘。先把最上面的盘A->B，把最下面的盘A->C，把B塔的所有盘从B->C

```java
    public static void hanoiTower(int num, char a, char b, char c) {
        if (num == 1) {
            System.out.println("第" + num + "盘子从" + a + "->" + c);
        } else {
            hanoiTower(num - 1, a, c, b);
            System.out.println("第" + num + "盘子从" + a + "->" + c);
            hanoiTower(num - 1, b, a, c);
        }
    }
```

# 动态规划

核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解。与分治不同的是，动态规划求解的问题，经分解得到的子问题往往不是互相独立的（即下一个阶段的求解是建立在上一个阶段的解的基础上）。可以通过填表的方式来逐步推进。

## 背包问题

一个给定容量的背包，若干具有一定价值和重量的物品。如何选择物品放入背包使背包的价值最大，又分01背包和完全背包（每种物品有无限件）

e.g 有一个01背包，容量为4榜，有以下物品

| 物品 | 重量 | 价格 |
| ---- | ---- | ---- |
| 吉他 | 1    | 1500 |
| 音响 | 4    | 3000 |
| 电脑 | 3    | 2000 |

动态规划，每次遍历到第i个物品，根据w[i]和v[i]来确定是否需要将物品放入背包中，即对于给定的n个物品，设v[i], w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v [i] [j] 为前i个物品能够装如容量为 j 的背包的最大价值

| 物品 | 0磅  | 1       | 2       | 3       | 4                |
| ---- | ---- | ------- | ------- | ------- | ---------------- |
|      | 0    | 0       | 0       | 0       | 0                |
| G    | 0    | 1500(G) | 1500(G) | 1500(G) | 1500(G)          |
| S    | 0    | 1500(G) | 1500(G) | 1500(G) | 3000(S)          |
| L    | 0    | 1500(G) | 1500(G) | 2000(L) | 2000(L) +1500(G) |

```java
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1, 4, 3}; //物品重量
        int[] val = {1500, 3000, 2000}; //物品价值
        int m = 4; //背包容量
        int n = val.length; //物品个数

        //v[i][j]表示在前i个物品中能装入容量为j的背包中的最大价值
        int[][] v = new int[n + 1][m + 1];

        for (int i = 1; i < v.length; i++) {    //不处理第一行和第一列
            for (int j = 1; j < v[0].length; j++) {
                //由于w和val数组下标都是从0开始,故注意第i个物品的重量为w[i-1],价值为v[i-1]
                //新增商品的容量大于当前背包的容量，直接使用上一格装入策略
                if (w[i - 1] > j) {
                    v[i][j] = v[i - 1][j];
                } 
                else {
                    v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                }
            }
        }

        //最大价值
        int maxVal = v[n][m];

        //加入的物品
        int j = v[0].length - 1;
        String item = "";
        for (int i = v.length - 1; i > 0; i--) {
            //若果v[i][j]>v[i-1][j],这说明第i件物品是放入背包的
            if (v[i][j] > v[i - 1][j]) {
                item = i + " " + item;
                j -= w[i - 1];
            }
            if (j == 0) {
                break;
            }
        }
        System.out.println(item);
    }
}

```

### 完全背包

01背包由于一个物品只能放一次，在前一次（i-1种物品）基础上解决当前问题（i种物品），所以是v [i-1] [j - w[i - 1]]。完全背包可以考虑放入一个物品 i 时应当考虑还可能继续放入 i，所以公式变成

```java
Math.max(v[i - 1][j], val[i - 1] + v[i][j - w[i - 1]])
```

# 贪心算法

在对问题进行求解时，在每一步选择中都采取最好的选择，从而希望能够导致结果是最好的算法。得到的结果不一定是最优的结果，但是都是相对接近最优解的结果。

## 集合覆盖

假设存在下面需要付费的广播台，以及广播台可以覆盖的地区。如何选择最少的广播台，让所有的地区都能接受到信号

| 广播台 | 地区           |
| ------ | -------------- |
| k1     | 北京 上海 天津 |
| k2     | 广州 北京 深圳 |
| k3     | 成都 上海 杭州 |
| k4     | 上海 天津      |
| k5     | 杭州 大连      |

//穷举法列出每个可能的广播台集合，n个台，有$2^n-1$ 个组合，慢

1.  遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区电台
2.  将这个电台加入到一个集合中，把该电台覆盖的地区在下次比较时去掉
3.  重复直到覆盖了全部地区

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm {
    public static void main(String[] args) {
        HashMap<String, HashSet<String>> broadcasts = new HashMap<>();
        HashSet<String> hs1 = new HashSet<>();
        HashSet<String> hs2 = new HashSet<>();
        HashSet<String> hs3 = new HashSet<>();
        HashSet<String> hs4 = new HashSet<>();
        HashSet<String> hs5 = new HashSet<>();
        hs1.add("北京");
        hs1.add("上海");
        hs1.add("天津");
        hs2.add("广州");
        hs2.add("北京");
        hs2.add("深圳");
        hs3.add("成都");
        hs3.add("上海");
        hs3.add("杭州");
        hs4.add("上海");
        hs4.add("天津");
        hs5.add("杭州");
        hs5.add("大连");
        broadcasts.put("K1", hs1);
        broadcasts.put("K2", hs2);
        broadcasts.put("K3", hs3);
        broadcasts.put("K4", hs4);
        broadcasts.put("K5", hs5);

        //所有地区
        HashSet<String> allAreas = new HashSet<>();
        allAreas.addAll(hs1);
        allAreas.addAll(hs2);
        allAreas.addAll(hs3);
        allAreas.addAll(hs4);
        allAreas.addAll(hs5);

        //存放选择的电台集合
        ArrayList<String> selects = new ArrayList<>();
        //临时集合，在遍历过程中电台覆盖区域和当前还没被覆盖区域的交际
        HashSet<String> tempSet = new HashSet<>();
        String maxKey = null;
        while (allAreas.size() != 0) {
            maxKey = null;
            for (String key : broadcasts.keySet()) {
                tempSet.clear();
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //求出tempSet和allAreas的交集，存在tempSet中
                tempSet.retainAll(allAreas);
                if (tempSet.size() > 0 &&
                        (maxKey == null || tempSet.size() > broadcasts.get(maxKey).size())) {
                    maxKey = key;
                }
            }
            if (maxKey != null) {
                selects.add(maxKey);
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
    }

}
```

