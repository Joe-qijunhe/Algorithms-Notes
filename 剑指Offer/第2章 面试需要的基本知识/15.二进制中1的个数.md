# 题目

请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有两位是1.因此，如果输入9，则该函数输出2。

# 解法

## 可能引起死循环的解法

先判断整数二进制表示中最右边一位是不是1，接着把输入的整数右移一位，此时原来从右边数起的第二位被移到最右边了，再判断是不是1。这样每次移动一位，直到整个整数变成0为止 。

如果数是一个负数，如`0x8000000`（8的二进制是1000），当把他右移一位时，由于算术位移，移位后的最高位会设为1，变成`0xC000000`。如果一直做右移运算，这个数字会变成`0XFFFFFFFF`，进入死循环

```java
    public static int numberOf1(int n) {
        int count = 0;
        while (n ！= 0) {
            if ((n & 1) == 1) {
                count++;
            }
            n = n >> 1;
        }
        return count;
    }
```

## mask法

当检查第 i 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i  位为 1 时，运算结果不为 0。

```java
    public static int numberOf1(int n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            int mask = 1 << i;
            if ((n & mask) != 0) {
                ret++;
            }
        }
        return ret;
    }
```

## 位运算优化

在分析这种算法之前 ，我们 先来分析把一 个数减去1的情况 。如果一个整数不等于0 , 那么该整数的二进制表示中至少有一位是1。

-   先假设这个数的最右边一位是1, 那么减去1 时， 最后一 位变成 0 而其 他所有位都保待不变 。也就是最后 一 位相当于做了取反操作，由 1 变成了 0 。
-   接下来假设最后 一位不是1 而是0 的情况 。如果该整数的二 进制表示中最右边的1 位于第 m 位，那么减去1 时，第 m 位由1 变成 0，而第 m 位之后的所有 0 都变成1，整数中第 m 位之前的所有位都保持不变 。 举个例子 ：一 个 二进制数1100 ，它的第二位是从最右边数起的 一 个1 。 减去1 后，第二位变 成 0，它后面的两位 0 变成1，而前面的1 保持不变 ，因此得到的结果是1011。

在前面两种情况中，我们发现把一个整数减去1，都是 把最右边的1 变成 0 。如果它的右边还有 0,则所有 的 0 变成1，而它左边的所有位都保持不变 ， 接下来我们把一 个整数和它减去1的结果做位与运算 ，相当于把它最右边的1 变 成 0 。 还是以前面的1100 为例，它减去1 的 结果是1011 。我们再把1100 和1011 做位与运算，得到的结果是1000 。 我们把1100 最右边的1 变成了0，结果刚好就是1000 。

我们把上面的分析总 结起来就是 ： 把一个整数减去1，再和原整数做与运算， 会把该整数最右边的1变成 0。 那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作 。 

```java
    public static int numberOf1(int n) {
        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
```

# 相关题目

-   用一条语句判断一个整数是不是2的整数次方 （4,8,16,32...）。 一 个整数如果是2的整数次方 ，那么它的二进制表示中有且只有一位是1 , 而其他所有位都是 0 。 根据前面的分析，把这个整数减去1 之后再和它自己做与运算，这个整数中唯一的1就会变成 0 。
-   输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到n 。比如10的二进制表示为1010，13 的二进制表示为1101, 需要改变1010 中的 3 位才能得到1101 。 我们可以分为两步解决这个问 题：第 一 步求这两个数的异或；第二步统计异或结果中1的位数 。

# 举一反三

把一个整数减去1，之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成 0。很多二进制的问题都可以用这种思路解决 。

