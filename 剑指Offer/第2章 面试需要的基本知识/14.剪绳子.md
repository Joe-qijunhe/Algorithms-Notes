

# 题目

给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],···,k[m]。请问k[0]×k[1]×···×k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

# 解法

## 动态规划

如果面试题是求一个问题的**最优解**（通常是求最大值或者最小值），而且该问题能够分解成若干个**子问题**，并且子问题之间还有**重叠**的更小的子问题，就可以考虑用动态规划来解决这个问题 。

我们在应用动态规划之前要分析能否把大问题分解成小问题，分解后的每个小问题也存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解 ，那么我们可以应用动态规划解决这个问题 。

### 此题中的体现

例如在面试题14 中，我们如何把长度为 n 的绳子剪成若干段，使得得到的各段长度的乘积最大 。这个问题的目标是求剪出的各段绳子长度的**乘积最大值**，也就是求一个问题的最优解——这是可以应用动态规划求解的问题的第一个特点 。

我们把长度为 n 的绳子剪成若干段后得到的乘积最大值定义为函数f(n) 。假设我们把第一刀剪在长度为 i ( 0<i<n ) 的位置，于是把绳子剪成了长度分别为 i 和 n-i 的两段 。我们要想得到整个问题的最优解 f(n)，那么要同样用最优化的方法把长度为 i 和 n-i 的两段分别剪成若干段，使得它们各自剪出的每段绳子的长度乘积最大 。 也就是说整体问题的最优解是依赖各个子问题的最优解——这是可以应用动态规划求解的问题的第二个特点。

我们把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题——这是可以应用动态规划求解的问题的第三个特点 。还是以面试题14为例，假设绳子最初的长度为10， 我们可以把绳子剪成长度分别为 4 和 6 的两段 ，也就是 f(4)和 f(6)都是 f(10) 的 子问题 。接下来分别求解这两个子问题 。我们可以把长度为 4 的绳子剪成均为 2 的 两段，即 f(2)是 f(4) 的子问题 。同样，我们也可以把长度为 6 的绳子剪成长度分别为 2 和 4 的
两段，即 f(2)和 f(4)都是 f(6) 的子问题 。我们注意到 f(2)是 f(4)和 f(6)**公共的更小的子问题** 。

由于子问题在分解大问题的过程中重复出现 ，为了避免重复求解子问题，我们可以用从下往上的顺序先计算 小问题的最优解并存储下来，再以此为基础求取大问题的最优解 。**从上往下分析问题 ，从下往上求解问题**，这是可以应用动态规划求解的问题的第四个特点 。 在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分面试题都是存储在一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题 。在应用动态规划的时候，我们每一步都可能面临若干个选择 。在求解面试题14 时，我们在剪第一刀的时候就有 n-1 个 选择 。 我们可以剪在长度为1 ,2 ,……,n- 1 的任意位置。由于我们事先不知道剪在哪个位置是最优的解法，只好把所有的可能都尝试一 遍，然后比较得出最优的剪法 。 如果用数学的语言来表示 ，这就是max( f(i) * f(n-i) )其中 0< i < n 。

### 剑指offer法

```java
    public static int maxProductAfterCutting(int length) {
        // 直接返回长度小于等于3的最大乘积
        if (length < 2) {
            return 0;
        }
        if (length == 2) {
            return 1;
        }
        if (length == 3) {
            return 2;
        }
        // products[i]表示把长度为i的绳子剪成若干段之后各段长度乘积的最大值，即f(i)
        int[] products = new int[length + 1];
        // 因为用到base case时，肯定是已经切过一刀了，所以最大值可以是没切的状态
        products[0] = 0;
        products[1] = 1;
        products[2] = 2;
        products[3] = 3;

        for (int i = 4; i <= length; i++) {
            int max = 0;
            // 由于乘法交换律，只需要检查一半
            for (int j = 1; j <= i / 2; j++) {
                int product = products[j] * products[i - j];
                if (product > max) {
                    max = product;
                }
            }
            products[i] = max;
        }
        return products[length];
    }
```

### LeetCode法

>   与剑指offer的base case不同，剑指offer的由于知道length大于4时，肯定切一刀的乘积大，所以base case是可以不切的。LeetCode版需要考虑第一段（特别是长度小于4时）不切的情况。

1.   我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来
2.   用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1
3.   我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪
4.   剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])
5.   第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为
     dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
6.   最后返回dp[n]即可

```java
    public static int cuttingRope(int n) {
        // dp[i]表示长度为i的绳子剪成m段后的最大乘积
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for(int i = 3; i < n + 1; i++){
            for(int j = 2; j < i; j++){
                // 第一刀剪在j，剩下部分i-j不剪了
                int productNoCut = j * (i - j);
                // 第一刀剪在j，剩下部分i-j继续剪
                int productCut = j * dp[i - j];
                int greaterProduct = Math.max(productNoCut, productCut);
                dp[i] = Math.max(dp[i], greaterProduct);
            }
        }
        return dp[n];
    }
```



## 贪婪算法

贪婪算法和动态规划不一样。当我们应用贪婪算法解决问题的时候 ，每一步都可以做出一个贪婪的选择，基于这个选择，我们确定能够得到最优解。还是以面试题 14" 剪绳子”为例 ，如果绳子的长度大于5，则每次都剪出一段长度为3的绳子。如果剩下的绳子的长度仍然大于 5, 则接着剪出一段长度为3 的绳子。接下来重复这个步骤 ，直到剩下的绳子的长度小于 5。剪出一段长度为 3 的绳子，就是我们在每一步做出的贪婪选择。为什么这样的贪婪选择能得到最优解？这是我们应用贪婪算法时都需要问的问题 ，需要用数学方式来证明贪婪选择是正确的 。

接下来我们证 明这种思路的正确性 。首先，当 n >= 5 的时候 ，我们可以证明2 * (n-2 ) > n 并且 3 * (n-3) > n 。
也就是说，当绳子剩下的长度大于或者等 5 的时候，我们就把它剪成长度为 3 或者 2 的绳子段 。另外，当 n >= 5 时，3(n-3) >= 2(n-2)，因此我们应该尽可能地多剪长度为 3 的绳子段 。

前面证明的前提是 n >= 5 ，那么当绳子的长度为 4 呢？在长度为 4 的绳子上剪一刀，有两种可能的结果 ：

-   剪成长度分别为1 和 3 的两根绳子
-   两根长度都为 2 的绳子。

注意到 2 * 2 > 1 * 3 ，也就是说，当绳子长度为 4 时 其实没有必要剪，只是题目的要求是至少要剪一刀 。

```java
public int maxProductAfterCutting(int length) {
    if (length < 2) {
        return 0;
    }
    if (length == 2) {
        return 1;
    }
    if (length == 3) {
        return 2;
    }
    // 尽可能多地剪去长度为3的绳子段
    int timesOf3 = length / 3;
    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2x2>3x1
    if (length - timesOf3 * 3 == 1) {
        timesOf3 -= 1;
    }
    int timesOf2 = (length - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2));
}
```

