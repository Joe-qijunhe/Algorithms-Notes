# 题目

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。

例如，输入数组 {2 ,4, 3, 6, 3, 2, 5, 5}，因为只有 4 和 6 这两个数字只出现了一次，其他数字都出现了两次，所以输出 4 和 6 。

## 解法

先考虑这个数组中只有一个数字只出现了一次，其他数字都出现了两次，怎么找出这个数字？这两道题目都在强调一个（或两个）数字只出现一次，其他数字出现两次 。这有什么意义呢？我们想到异或运算的一个性质：**任何一个数字异或它自己都等于 0**。 也就是说，如果我们从头到尾依次异或数组中的每个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了 。

想明白怎么解决这个简单的问题之后，我们再回到原始的问题，看看能不能运用相同的思路 。我们试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次：

**我们从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果**，因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为 0，也就是说，**在这个结果数字的二进制表示中至少有一位为 1**。（异或中为1说明两个数字在这位上不一样！）我们在结果数字中找到第一个为 1 的位的位置，记为第 n 位。现在我们以第 n 位是不是 1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 n 位都是 1，而第二个子数组中每个数字的第 n 位都是 0。

由于我们分组的标准是数字中的某一位是 1 还是 0，那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。

我们已经知道如何在数组中找出唯一一个只出现一次的数字，因此，到此为止所有的问题都已经解决了。

```java
    public static int[] findNumsAppearOnce(int[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        int[] result = new int[2];
        // 两个数字的异或结果
        int xor = 0;
        for (int num : array) {
            xor ^= num;
        }
        // 第一个为 1 的位的位置
        int index = 0;
        while (xor > 0 && (xor & 1) == 0) {
            xor >>= 1;
            index++;
        }
        // 根据index位是不是 1 为标准划分数组
        for (int num : array) {
            if (((num >> index) & 1) > 0) {
                result[0] ^= num;
            } else {
                result[1] ^= num;
            }
        }
        return result;
    }
```

# 题目

在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

## 解法

不能使用异或，因为三个相同的数字的异或结果还是该数字，但是可以沿用位运算的思路：如果一个数字出现三次，那么它的二进制表现表示的每一位也出现三次。如果把所有出现三次的数字的二进制表示的每一位都加起来（单纯地加起来，即统计出现次数），那么每一位的和都能被3整除。

我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被 3 整除，那么那个只出现一次的数字二进制表示中对应的那一位是 0；否则就是 1 。

```java
    public static int singleNumber(int[] nums) {
        if (nums == null) {
            return 0;
        }
        int[] bitSum = new int[32];
        // 把数组中所有数字的二进制表示的每一位都加起来
        for (int num : nums) {
            int mask = 1;
            for (int j = 31; j >= 0; j--) {
                if ((num & mask) != 0) {
                    bitSum[j]++;
                }
                mask <<= 1;
            }
        }
        int result = 0;
        for (int i = 0; i < 32; i++) {
            result <<= 1;
            // 如果不能被3整除，说明result的这一位是1
            result += bitSum[i] % 3;
        }
        return result;
    }
```

