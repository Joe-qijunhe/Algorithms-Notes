# 题目

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

# 解法

## 逐个判断每个整数是不是丑数的解法，直观但不够高效

所谓一个数 m 是另一个数 n 的因子 ， 是指 n 能被 m 整除也就是 n % m = 0 。 根据丑数的 定义，丑数只能被2 、3 和 5 整除。也就是说，如果一个数能被2整除，就连续除以2；如果能被 3 整除，就连续除以 3；如果能被 5整除，就除以连续 5 。 如果最后得到的是1，那么这个数就是丑数。接下来只需要按照顺序判断每个整数是不是丑数。

但时间效率不高，不管一个数是不是丑数，我们都需要对它进行计算。

```java
    public int GetUglyNumber_Solution(int index) {
        if (index <= 0) {
            return 0;
        }
        int number = 0;
        for (int i = 0; i < index;) {
            number++;
            if (isUgly(number)) {
                i++;
            }
        }
        return number;
    }
    
    private boolean isUgly(int number) {
        while (number % 2 == 0) {
            number /= 2;
        }
        while (number % 3 == 0) {
            number /= 3;
        }
        while (number % 5 == 0) {
            number /= 5;
        }
        return number == 1;
    }
```

## 创建数组保存已经找到的丑数，用空间换时间的解法

试着找到一种只计算丑数的方法。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此我们可以创建一个数组，里面的数字都是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。

这种思路的关键在于**怎样确保数组里面的丑数是排好序的**。 假设数组中已经有若干个排好序的丑数，并且把已有最大的丑数记作M，接下来分析如何生成下一个丑数 ：该丑数肯定是前面某一个丑数乘以 2、3 或者 5 的
结果，所以我们首先考虑把已有的每个丑数乘以 2 。 在乘以 2 的时候 ，能得到若干个小于或等于 M 的结果。由于是按照顺序生成的，小于或者等于 M肯定已经在数组中了，我们不需再次考虑； 还会得到若干个大于 M 的结果，但我们只需要第一个大于 M 的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2后大于 M 的 结果记为 M2 。同样 ，我们把已有的每个丑数乘以 3 和5，能得到第 一个大于 M 的 结果 M3 和 M5。 那么下 一 个丑数应该是 M2、M3 和 M5 这3个数的最小者。

在前面分析的时候提到把已有的每个丑数分别乘以 2、3 和 5。事实上这不是必需的，因为己有的丑数是按顺序存放在数组中的。对于乘以 2 而言，肯定存在某一个丑数T2，排在它之前的每个丑数乘以2得到的结果都会 小于已有最大的丑数，在它之后的每个丑数乘以 2 得到的结果都会太大 。我们只需记下这个丑数的位置，同 时每次生成新的丑数的时候去更新这个T2即可。对于3和5同理。

```java
    public static int getUglyNumber(int index) {
        if (index < 0) {
            return 0;
        }
        int[] ugly = new int[index];
        ugly[0] = 1;
        int m2 = 0;
        int m3 = 0;
        int m5 = 0;
        for (int i = 1; i < index; i++) {
            ugly[i] = Math.min(ugly[m2] * 2, Math.min(ugly[m3] * 3, ugly[m5] * 5));
            while (ugly[m2] * 2 <= ugly[i]) {
                m2++;
            }
            while (ugly[m3] * 3 <= ugly[i]) {
                m3++;
            }
            while (ugly[m5] * 5 <= ugly[i]) {
                m5++;
            }
        }
        return ugly[index - 1];
    }
```

